= State Charts for Clojure(script)
:author: Tony Kay
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: images
:scriptsdir: js
:imagesoutdir: generated/images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]


An implementation of state charts that use the SCXML
structure and semantics (as far as they are defined), without the need for XML.

It is a simple exercise to convert an SCXML document to/from the
Clojure data structures used by this library, which
means existing tooling can pretty easily be used to design or
document your machine.

= Status

image:https://img.shields.io/clojars/v/com.fulcrologic/statecharts.svg[link=https://clojars.org/com.fulcrologic/statecharts]
image:https://circleci.com/gh/fulcrologic/statecharts/tree/main.svg?style=svg["CircleCI", link="https://circleci.com/gh/fulcrologic/statecharts/tree/main"]

ALPHA. The algorithm is written and (seems to be) working. Some aspects exist and are "called",
but are currently stubs. If you want to play with it, I recommend using deps with a git SHA of the latest
commit.

* Implemented
** DataModel, ExecutionModel, and EventQueue abstractions, along with a simple implementation.
** Compound, parallel, atomic, initial, and final states
** Transitions
** Transition guards
** Transition execution
** Extensible executable elements
** Simple dev-mode SCXML -> CLJC conversion utility (see src/dev).
** History (deep and shallow). written, not tested
** Enter, exit (written, untested)

* TODO
** Send/invoke (unimplemented)

See Conformance.adoc at the root of this repository for notes on
decisions that might affect exact conformance to the standard.

= Usage

This library supports a lot of flexibility, and has many long-term goals:

* Compatible with distributed systems. For example a cluster might run long-lived state machine sessions that
  can be serviced by any node of the custer.
* State machine definitions can be versioned.
* Everything *can* be made to be serializable (including the code in the machine).

Thus you can define (via protocols):

* How to interpret the executable code of the state machine (e.g. on-exit, cond, etc.). You could, for example,
  use strings for those, and Javascript or SCI to interpret them (making the machine completely serializable).
* How the data model of the states work. You can, for example, hook the data model into Fulcro, Reagent, Datomic, Datascript, etc.
* The implementation of the event queue. This allows you to generate state machines that know how
  to send events to each other, can be distributed, etc.  It is necessary to make this part of the internals because
  the state charts support sending events from within state code, which as we mentioned above, could be interpreted
  by your own execution model and may not actually be Clojure(script).
* The actual state chart processing semantics/algorithm. A version of the W3C 2015-09-01 recommendation for SCXML is provided
  as a default.

However, it would be a real hassle if you had to set up all of that stuff just to get what many people want:
A statechart that can run in CLJC, using Clojure code, and a functional interface where you can manually
send events to the machine. Thus, a reasonable default implementation is provided for all of the above, and
it is simple to expand this to meet your needs.

Here's a traffic light example from the `src/examples` directory in this repository:

-----
(ns traffic-light
  (:require
    [com.fulcrologic.statecharts :as sc]
    [com.fulcrologic.statecharts.state-machine :as sm :refer [machine]]
    [com.fulcrologic.statecharts.elements :refer [state parallel transition]]
    [com.fulcrologic.statecharts.events :refer [new-event]]
    [com.fulcrologic.statecharts.simple :refer [new-simple-machine]]
    [com.fulcrologic.statecharts.protocols :as sp]))

(defn nk
  "Narrow the meaning of a keyword by turning the full original keyword into a namespace
   and adding the given `new-name`.

   E.g.

   ```
   (nk :a/b \"c\") => :a.b/c
   ```
  "
  [k new-name]
  (let [old-ns (namespace k)
        nm     (name k)
        new-ns (if old-ns
                 (str old-ns "." nm)
                 nm)]
    (keyword new-ns new-name)))

(defn traffic-signal [id initial]
  (let [red     (nk id "red")
        yellow  (nk id "yellow")
        green   (nk id "green")
        initial (nk id (name initial))]
    (state {:id      id
            :initial initial}
      (state {:id red}
        (transition {:event :swap-flow :target green}))
      (state {:id yellow}
        (transition {:event :swap-flow :target red}))
      (state {:id green}
        (transition {:event :warn-traffic :target yellow})))))

(defn ped-signal [id initial]
  (let [red            (nk id "red")
        flashing-white (nk id "flashing-white")
        white          (nk id "white")
        initial        (nk id (name initial))]
    (state {:id      id
            :initial initial}
      (state {:id red}
        (transition {:event :swap-flow :target white}))
      (state {:id flashing-white}
        (transition {:event :swap-flow :target red}))
      (state {:id white}
        (transition {:event :warn-pedestrians :target flashing-white})))))

(def traffic-lights
  (machine {}
    (parallel {}
      (traffic-signal :east-west :green)
      (traffic-signal :north-south :red)

      (ped-signal :cross-ew :red)
      (ped-signal :cross-ns :white))))

(defn show-states [wmem]
  (println (sort (filter #{:north-south/red
                           :north-south/yellow
                           :north-south/green
                           :east-west/red
                           :east-west/yellow
                           :east-west/green
                           :cross-ns/red
                           :cross-ns/white
                           :cross-ns/flashing-white
                           :cross-ew/red
                           :cross-ew/white
                           :cross-ew/flashing-white} (::sc/configuration wmem)))))

(comment
  (def processor (new-simple-machine traffic-lights {}))
  (def s0 (sp/start! processor 1))
  (show-states s0)
  (def s1 (sp/process-event! processor s0 (new-event :warn-pedestrians)))
  (show-states s1)
  (def s2 (sp/process-event! processor s1 (new-event :warn-traffic)))
  (show-states s2)
  (def s3 (sp/process-event! processor s2 (new-event :swap-flow)))
  (show-states s3)
  (def s4 (sp/process-event! processor s3 (new-event :warn-pedestrians)))
  (show-states s4)
  (def s5 (sp/process-event! processor s4 (new-event :warn-traffic)))
  (show-states s5)
  (def s6 (sp/process-event! processor s5 (new-event :swap-flow)))
  (show-states s6))
-----

If you run the items in the comment block, you'll see:

[source]
-----
(:cross-ew/red :cross-ns/white :east-west/green :north-south/red)
(:cross-ew/red :cross-ns/flashing-white :east-west/green :north-south/red)
(:cross-ew/red :cross-ns/flashing-white :east-west/yellow :north-south/red)
(:cross-ew/white :cross-ns/red :east-west/red :north-south/green)
(:cross-ew/flashing-white :cross-ns/red :east-west/red :north-south/green)
(:cross-ew/flashing-white :cross-ns/red :east-west/red :north-south/yellow)
(:cross-ew/red :cross-ns/white :east-west/green :north-south/red)
-----

See the SCXML spec for how to structure elements. The structure and naming are kept close to that spec for easy
cross-referencing with its documentation.

= Guide

First some very important notes:

. Every node in a state chart has a UNIQUE ID. These IDs are autogenerated if you do not supply them.
. Most of the "executable content" elements described in the SCXML standard (e.g. `<if>`) are simply
collapsed into the `script` node.

== Terminology

Configuration:: When used in the context of a state chart, the configuration is the list of all active states. A
state is active if it or ANY of its children are active. Thus, a parallel machine with hierarchical states may
have a rather large set of IDs in its current configuration.

Working Memory:: A map of data that contains the current configuration of the state machine, and other information
 necessary to know its current full state (which states have had their data model initialized, possible data model
 tracking, etc.).

DataModel:: An implementation of the data model protocol defines how the data model of your chart works. The simple
implementation places the data in Working Memory, and treats lookups in a scoped fashion.

ExecutionModel:: An implementation of this protocol is handed the expressions that are included on the state chart, and
chooses how to run them. A default implementation requires that they be Clojure `(fn [env data])`, and simply calls them
with the contextual data for their location.

EventQueue:: Obviously a place to put events. In the case of this implementation the event queue is responsible for
delivery of events to "self", other statechart sessions (instances of other machines), remote services (e.g. send an email),
and for delayed delivery. The default implementation is a "manually polled" queue. This queue does not support most of
these features, and the delayed event delivery is manual (e.g. you have to poll it, or ask it when the next one should
happen and start a timer/thread). Creating a system that runs the loop and does the timed delivery is typically
how you would use these in a more serious/production environment.

Processor:: An implementation of the statechart algorithm. This library comes with an implementation that follows
(as closely as possible) the SCXML recommended standard from 2015. You may provide your own.

Session:: The combination of the content of the DataModel and Working Memory. I.e. all of the data you'd need in order
to resume working from where you last left off. Sessions typically have a unique ID, which could be used to store
sessions into durable storage when they are "idle", and are used for cross-session events.

== Data Models

The SCXML specification allows the implementation quite a bit of latitude in the interpretation of the chart's
data model. You could define scopes that nest, one global map of data that is visible everywhere, or hook your
data model to an external database.

See the docstrings in the `protocols` namespace.

== Execution

== Working Memory and Identity

The working memory of the state machine is plain EDN and contains no code.
It is serializable by nippy, transit, etc. Therefore, you can easily save
an active state machine by value into any data store. The value
is intended to be as small as possible so that storage can be efficient.

Every active state machine is assigned a ID on creation (which you
can override via `initialize`). This is intended as part of the story to
allow you to coordinate external event sources with working with
instances of machines that are archived in durable storage while idle.


= Relationship to SCXML

This library's internal implementation follows (as closely as possible) the official
https://www.w3.org/TR/2015/REC-scxml-20150901/#AlgorithmforSCXMLInterpretation[State Chart XML Algorithm]. In fact,
much of the implementation uses internal volatiles in order to match the imperative style of that doc for easier
comparison and avoidance of bugs.

The actual structure of the live CLJC data used to represent machines also closely mimics
the structure described there, but with some differences for convenient use in CLJC.

Specifically, executable content is *still* treated as *data*, but the XML nodes that
are described in the standard do *not* exist in this library, because a conformant
XML reader (which would need to be aware of the target execution model) can easily
translate such nodes into the target data representation (even if that target
representation is script strings).

Some of the data model elements are also abbreviated in a similar manner. See
the docstrings for details.

Thus, if you are trying to read SCXML documents you will need to write (or find) an
XML reader that can do this interpretation.

For example, an XML reader that targets https://github.com/babashka/sci[sci] (the
Clojure interpreter) might convert the XML (where `a` and `do-something` are implied
values in the data and excution model):

[source, xml]
-----
<if cond="(= 1 a)">
  (let [b (inc a)]
    (do-something b))
</if>
-----

into (scope and args still determined by the execution model selected):

[source, clojure]
-----
;; String-based interpretation
(script {:expr
  "(if (= 1 a)
     (let [b (inc a)]
       (do-something b)))"})

;; OR eval-based
(script {:expr
  '(if (= 1 a)
     (let [b (inc a)]
       (do-something b)))})

;; OR functional
(script {:expr (fn [env {:keys [a]}]
                  (if (= 1 a)
                    (let [b (inc a)]
                      (do-something b))))})
-----

If you're using XML tools to generate you machines, though, it's probably easiest to use
`script` tags to begin with.

== Related Work

The primary alternative to this library is https://github.com/lucywang000/clj-statecharts[clj-statecharts],
which is a fine library modelled after xstate.

This library exists for the following reasons:

* At the time this library was created, https://github.com/lucywang000/clj-statecharts/[clj-statecharts] was missing features. In particular history nodes,
  which we needed. I looked at clj-statecharts in order to try to add history, but some of the internal
  decisions made it more difficult to add (with correct semantics) and the Eclipse license made it less
  appealing for internal customization as a base in commercial software (see https://www.juxt.pro/blog/prefer-mit).
* To create an SCXML-like implementation that uses the algorithm defined
  in the W3C Recommended document, and can (grow to) run (with minor transformations) SCXML docs that are
  targeted to Clojure with the semantics defined there (such as they are).
* To define more refined abstract mechanisms such that the state charts can be associated to long-lived things
  (such as a monetary transaction that happens over time) and
  be customized to interface with things like durable queues for events (e.g. AWS SQS) and
  reliable timers.
* MIT licensing instead of Eclipse.

Other related libraries and implementations:

* https://xstate.js.org/[XState] : Javascript. Could be used from CLJS.
* https://commons.apache.org/proper/commons-scxml/[Apache SCXML] : Stateful and imperative. Requires writing classes. Requires you use XML.
* https://github.com/fulcrologic/fulcro/blob/develop/src/main/com/fulcrologic/fulcro/ui_state_machines.cljc[Fulcro UI State Machines]
: A finite state machine namespace (part of Fulcro) that is tightly coupled to Fulcro's needs (full stack operation in the context of
Fulcro UI and I/O).

== Conformance

This library was written using the reference implementation described in
the https://www.w3.org/TR/scxml[SCXML standard], but without the requirement
that the machine be written in XML.

Any deviation from the standard (as far as general operation of state transitions, order
of execution of entry/exit, etc.) should be considered a bug. Note that it is possible
for a bugfix in this library to change the behavior of your code (if you wrote it in
a way that depends on the misbehavior); therefore, even though
this library does not intend to make breaking changes, it is possible that a bugfix could affect
your code's operation.

If future versions of the standard are released that cause incompatible changes, then
this library will add a new namespace for that new standard (not break versioning).
